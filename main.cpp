//bu cs 591-w1 computational fabrication project//male/female part matching//wei jiang, youcun liu#include <iostream>#include <vector>#include <map>//pcl lib#include <pcl/point_types.h>//igl lib#include <igl/viewer/Viewer.h>#include <igl/copyleft/cgal/mesh_boolean.h>#include <igl/copyleft/cgal/convex_hull.h>//local headers#include "registration.h"#include "segmentation.h"#include "cap.h"#include "loader.h"#include "mesh_sampling.h"#include "cost.h"#include "hungarian.h"#include "visualize.h"#include "inertia.h"#include "alignment.h"#include "to_csv.h"#include "interactive_adjust.h"#include "screw.h"using namespace std;int main(int argc, char *argv[]){    int num_males = atoi(argv[1]);    string workspace = argv[2];    int clusters = atoi(argv[3]);    int density = atoi(argv[4]);    float smooth_f = stof(argv[5]);    vector<float> smooth;    for(int i = 6; i<argc;++i)        smooth.push_back(stof(argv[i]));    //0. load    Loader loader = Loader(workspace, num_males);    Eigen::MatrixXd female_v;    Eigen::MatrixXi female_f;    Eigen::MatrixXd female_vn;    vector<Eigen::MatrixXd> males_v;    vector<Eigen::MatrixXi> males_f;    vector<Eigen::MatrixXd> males_vn;    loader.get_female(female_v, female_f, female_vn);    loader.get_males(males_v, males_f, males_vn);    //1. get the convex hull of female part    Eigen::MatrixXd female_ch_v;    Eigen::MatrixXi female_ch_f;    igl::copyleft::cgal::convex_hull(female_v, female_ch_v, female_ch_f);////    //2. boolean minus: core_part = female_convex_hull - original_female//    Eigen::MatrixXd core_v;//    Eigen::MatrixXi core_f, J;//    igl::copyleft::cgal::mesh_boolean(female_ch_v, female_ch_f, female_v, female_f, "Minus", core_v, core_f, J);////    //3. remove overlap surface between core_part and female_convex_hull get the contact surface//    Eigen::MatrixXi core_nocap_f;//    move_cap(core_v, core_f, female_ch_v, female_ch_f, core_nocap_f);////    //4. do segmentation on female//    igl::writeOFF(workspace + "/tmp_off/tmp_female.off", core_v, core_nocap_f);//    vector<Eigen::MatrixXd> female_segments_v;//    vector<Eigen::MatrixXi> female_segments_f;//    segmentation(workspace + "/tmp_off/tmp_female.off", -1, clusters, smooth_f, female_segments_v, female_segments_f);////    //5. process males//    vector<vector<Eigen::MatrixXd>> males_segments_v;//    vector<vector<Eigen::MatrixXi>> males_segments_f;//    for(int i = 0; i<num_males;++i ){//        igl::writeOFF(workspace + "/tmp_off/tmp_male" + to_string(i)+".off", males_v[i], males_f[i]);//        vector<Eigen::MatrixXd> seg_v;//        vector<Eigen::MatrixXi> seg_f;//        int n_s = segmentation(workspace + "/tmp_off/tmp_male" + to_string(i)+".off", i, clusters, smooth[i], seg_v, seg_f);//        cout<<n_s<<endl;//        for(int n = 0; n<seg_v.size();++n){//            igl::writeOFF(workspace + "/tmp_off/male" + to_string(i) + "/male_part_" + to_string(n) + ".off",//                          seg_v[n], seg_f[n]);//        }//        males_segments_v.push_back(seg_v);//        males_segments_f.push_back(seg_f);//    }////////    6. mesh sampling////    vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> female_pcds;////    vector<vector<pcl::PointCloud<pcl::PointXYZ>::Ptr>> males_pcds;//////    vector<pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr> female_pcds;//////    vector<vector<pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr>> males_pcds;////    for(int i = 0;i<female_segments_v.size();++i){////        pcl::PointCloud<pcl::PointXYZ>::Ptr female_pcd =////                meshSampling(female_segments_v[i], female_segments_f[i], density);//////        pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr female_pcd =//////                meshSampling_n(female_segments_v[i], female_segments_f[i], density);////        female_pcds.push_back(female_pcd);////        ostringstream filename;////        filename << workspace << "/pcd/female/female_part_" << i<<".pcd";////        pcl::io::savePCDFileASCII(filename.str(), *female_pcd);////    }////    for(int i = 0;i<males_segments_v.size();++i){////        vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> tmp;//////        vector<pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr> tmp;////        for(int j = 0; j<males_segments_v[i].size();++j){////            pcl::PointCloud<pcl::PointXYZ>::Ptr male_pcd =////                    meshSampling(males_segments_v[i][j], males_segments_f[i][j], density);//////            pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr male_pcd =//////                    meshSampling_n(males_segments_v[i][j], males_segments_f[i][j], density);////            tmp.push_back(male_pcd);////            ostringstream filename;////            filename << workspace << "/pcd/male" << i << "/male_part_" << j<<".pcd";////            pcl::io::savePCDFileASCII(filename.str(), *male_pcd);////        }////        males_pcds.push_back(tmp);////    }////    //testing vertex2cloud//    vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> female_pcds;//    vector<vector<pcl::PointCloud<pcl::PointXYZ>::Ptr>> males_pcds;//    for(int i = 0;i<female_segments_v.size();++i){//        pcl::PointCloud<pcl::PointXYZ>::Ptr female_pcd = vertex2cloud(female_segments_v[i]);//        female_pcds.push_back(female_pcd);//        ostringstream filename;//        filename << workspace << "/pcd/vertex/female_part_" << i<<".pcd";//        pcl::io::savePCDFileASCII(filename.str(), *female_pcd);//    }//    for(int i = 0;i<males_segments_v.size();++i){//        vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> tmp;//        for(int j = 0;j<males_segments_v[i].size();++j){//            pcl::PointCloud<pcl::PointXYZ>::Ptr male_pcd = vertex2cloud(males_segments_v[i][j]);//            tmp.push_back(male_pcd);//            ostringstream filename;//            filename << workspace << "/pcd/vertex/male"<<i<<"_part_" << j<<".pcd";//            pcl::io::savePCDFileASCII(filename.str(), *male_pcd);//        }//        males_pcds.push_back(tmp);//    }////////    //speed up icp testing////    vector<pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr> female_pcds;////    vector<vector<pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr>> males_pcds;////    for(int i = 0;i<4;++i){////        pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr tmp(new pcl::PointCloud<pcl::PointXYZRGBNormal>);////        pcl::io::loadPCDFile<pcl::PointXYZRGBNormal> (workspace+"/pcd/female/female_part_"+to_string(i)+".pcd", *tmp);////        female_pcds.push_back(tmp);////    }////    for(int i = 0;i<num_males;++i){////        vector<pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr> tmp;////        for(int j = 0;j<6;++j){////            pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr male_pcd(new pcl::PointCloud<pcl::PointXYZRGBNormal>);////            if(pcl::io::loadPCDFile<pcl::PointXYZRGBNormal> (workspace+"/pcd/male"+to_string(i)+"/male_part_"+to_string(j)+".pcd",////                                                    *male_pcd)!=-1){////                tmp.push_back(male_pcd);////            }////        }////        cout<<tmp.size()<<endl;////        males_pcds.push_back(tmp);////    }//////    //7. icp//    int icp_iter = 100;//    Eigen::MatrixXd costs(female_pcds.size(), males_pcds.size());//    vector<vector<Eigen::Matrix4d>>//            index(female_pcds.size(),vector<Eigen::Matrix4d>(males_pcds.size(), Eigen::Matrix4d::Identity()));//    for(int i = 0; i<female_pcds.size(); ++i) {//        pcl::PointCloud<pcl::PointXYZ>::Ptr female = female_pcds[i];//        for (int j = 0; j < males_pcds.size(); ++j) {//            double min_cost = std::numeric_limits<double>::infinity();//            Eigen::Matrix4d T;////            for (int k = 0; k < males_pcds[j].size(); ++k) {//                pcl::PointCloud<pcl::PointXYZ>::Ptr male = males_pcds[j][k];//                pcl::PointCloud<pcl::PointXYZ>::Ptr tmp(new pcl::PointCloud<pcl::PointXYZ>(*male));//                Eigen::Matrix4d transformation_matrix = Eigen::Matrix4d::Identity();//                icpRegistration(tmp, female, icp_iter, transformation_matrix);////                //build homogenous vertex list x-by-4//                Eigen::MatrixXd tmp_homo_v(males_v[j].rows(), 4);//                tmp_homo_v.leftCols(3) = males_v[j];//                tmp_homo_v.rightCols(1) = Eigen::MatrixXd::Constant(tmp_homo_v.rows(), 1, 1);//                tmp_homo_v = tmp_homo_v * transformation_matrix.transpose();//                //male part after transformation//                Eigen::MatrixXd tmp_v(males_v[j].rows(), 3);//                tmp_v.leftCols(3) = tmp_homo_v.leftCols(3);////                double tmp_cost = cal_cost(tmp_v, males_f[j],//                                           female_v, female_f, female_ch_v, female_ch_f);////                if (tmp_cost <= min_cost) {//                    min_cost = tmp_cost;//                    T = transformation_matrix;//                }//            }////            costs(i, j) = min_cost;//            index[i][j] = T;////        }//    }//    cout<<costs<<endl;////    //save costs and matrices for fast testing//    writeToCSV(workspace+"/costs", costs);//    writeToCSV(workspace+"/matrix", index);    //read costs and matrices    Eigen::MatrixXd costs(4, 4);    vector<vector<Eigen::Matrix4d>> index;//(4,vector<Eigen::Matrix4d>(4, Eigen::Matrix4d::Identity()));    readFromCSV(workspace,costs,index);    vector<Eigen::MatrixXd> my_females_v;    vector<Eigen::MatrixXi> my_females_f;    for(int i=0;i<4;++i){        Eigen::MatrixXd tmp_v;        Eigen::MatrixXi tmp_f;        igl::readOFF(workspace+"/segmentation/female/Segment_"+to_string(i)+".off", tmp_v, tmp_f);        my_females_v.push_back(tmp_v);        my_females_f.push_back(tmp_f);    }    //8. assignment problem    vector< vector<double> > costMatrix;    for(int i = 0; i<costs.rows();++i){        vector<double> v;        for(int j = 0;j<costs.cols();++j)            v.push_back(costs(i,j));        costMatrix.push_back(v);    }    HungarianAlgorithm HungAlgo;    vector<int> assignment;    double cost = HungAlgo.Solve(costMatrix, assignment);    for (unsigned int x = 0; x < costMatrix.size(); x++)        std::cout << x << "," << assignment[x] << "\t";    std::cout << "\ncost: " << cost << std::endl;////    //9. optimize matching result//    vector<Eigen::Vector3d> axiss;//    for(int j =0;j<assignment.size();++j){//        if(costs(j, assignment[j])!=0){//            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud2 = vertex2cloud(males_v[assignment[j]]);//            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud = vertex2cloud(my_females_v[j]);//            Align a = Align(cloud2, cloud);//            a.run();//            vector<Eigen::Matrix4d> T = a.get_matrix();//            double min_cost = std::numeric_limits<double>::infinity();//            Eigen::Vector3d axis;//            Eigen::Matrix4d revised_T;////            for(int i = 0;i<T.size();++i){////                Eigen::MatrixXd this_tmp_homo_v(males_v[assignment[j]].rows(), 4);//                Eigen::MatrixXd this_tmp_v(males_v[assignment[j]].rows(), 3);//                this_tmp_homo_v.leftCols(3) = males_v[assignment[j]];//                this_tmp_homo_v.rightCols(1) = Eigen::MatrixXd::Constant(this_tmp_homo_v.rows(), 1, 1);//                this_tmp_homo_v = this_tmp_homo_v * (T[i]).transpose();////                this_tmp_v.leftCols(3) = this_tmp_homo_v.leftCols(3);////                double c = cal_cost(this_tmp_v, males_f[assignment[j]], female_v, female_f, female_ch_v, female_ch_f);//                if(c<min_cost){//                    min_cost = c;//                    axis = a.get_axis(i);//                    revised_T = T[i];//                }//            }//            index[j][assignment[j]] = revised_T;//            axiss.push_back(axis);//            index[j][assignment[j]] = T[0];//            axiss.push_back(a.get_axis(0));//        }else{//                pcl::PointCloud<pcl::PointXYZ>::Ptr cloud2 = vertex2cloud(males_v[assignment[j]]);//                vector<Eigen::Vector3d> kkk = get_inertia(cloud2);//                axiss.push_back(kkk[1]);//        }//    }    //10. show result    //visualize(assignment, index, female_v, female_f, males_v, males_f);    //11. interactive adjustment//    vector<Eigen::MatrixXd> ret_males_v;//    vector<Eigen::MatrixXi> ret_males_f;//    GUI(female_v, female_f, males_v, males_f, assignment, index, axiss, ret_males_v, ret_males_f);//    for(int i =0; i<ret_males_v.size();++i){//            igl::writeOBJ(workspace + "/ret/male_" + to_string(i) + ".obj", ret_males_v[i], ret_males_f[i]);//    }//    igl::writeOBJ(workspace + "/ret/female.obj", female_v, female_f);    //speed up screwing testing    vector<Eigen::MatrixXd> ret_males_v;    vector<Eigen::MatrixXi> ret_males_f;    for(int i = 0; i<4;++i){        Eigen::MatrixXd ret_male_v;        Eigen::MatrixXi ret_male_f;        igl::readOBJ(workspace + "/ret/male_" + to_string(i) + ".obj", ret_male_v, ret_male_f);        ret_males_v.push_back(ret_male_v);        ret_males_f.push_back(ret_male_f);    }    //12. creating screw    vector<Eigen::MatrixXd> screws_v;    vector<Eigen::MatrixXi> screws_f;    for(int k=0;k<my_females_v.size();++k){        Eigen::MatrixXd fe;        fe = my_females_v[k];        map<double, vector<Eigen::Vector3d>, greater<double>> tmp;        for(int i=0;i<fe.rows();++i){            auto it = tmp.find(fe(i,1));            if(it == tmp.end()){                vector<Eigen::Vector3d> a = {fe.row(i)};                tmp.insert(pair<double,vector<Eigen::Vector3d>>(fe(i,1),a));            }else{                (it->second).push_back(fe.row(i));            }        }        double H = - (++tmp.begin())->first + tmp.begin()->first;        double r;        Eigen::Vector3d c;        get_center((tmp.begin())->second[0], (tmp.begin())->second[1], (tmp.begin())->second[2], r, c);        c(1) = (++tmp.begin())->first;        Eigen::MatrixXd screw_v;        Eigen::MatrixXi screw_f;        draw_screw(c, r, H, false, screw_v, screw_f);        igl::writeOBJ(workspace+"/ret/screw_"+to_string(k)+".obj", screw_v, screw_f);        tmp.clear();        screws_v.push_back(screw_v);        screws_f.push_back(screw_f);    }    //13. implement screw    for(int i=0;i<screws_v.size();++i){        Eigen::MatrixXi jj;        Eigen::MatrixXi jj2;        igl::copyleft::cgal::mesh_boolean(female_v, female_f, screws_v[i], screws_f[i], "Minus",                                          female_v, female_f, jj);        igl::copyleft::cgal::mesh_boolean(ret_males_v[assignment[i]], ret_males_f[assignment[i]],                                          screws_v[i], screws_f[i], "Union",                                          ret_males_v[assignment[i]], ret_males_f[assignment[i]], jj2);        igl::writeOBJ(workspace+"/ret/final_m_"+to_string(assignment[i])+".obj",                      ret_males_v[assignment[i]], ret_males_f[assignment[i]]);    }    igl::writeOBJ(workspace+"/ret/final_fe.obj", female_v, female_f);    return 0;}